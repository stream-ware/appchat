"""
Streamware App Generator
Generates apps from:
- Library registries (npm, pypi, docker)
- API documentation URLs
- Git repositories
Uses LLM to generate Makefiles when missing
"""

import os
import re
import json
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

logger = logging.getLogger("streamware.app_generator")


@dataclass
class LibraryRegistry:
    """Library registry configuration"""
    id: str
    name: str
    type: str  # npm, pypi, docker, cargo, go
    search_cmd: str
    install_cmd: str
    run_cmd: str
    dockerfile_template: str = ""


class AppGenerator:
    """
    Generates Streamware apps from various sources:
    - npm packages
    - PyPI packages
    - Docker images
    - API documentation URLs
    - Git repositories
    """
    
    LIBRARY_REGISTRIES = {
        "npm": LibraryRegistry(
            id="npm",
            name="NPM Registry",
            type="npm",
            search_cmd="npm search {query} --json",
            install_cmd="npm install {package}",
            run_cmd="npx {package}",
            dockerfile_template="""FROM node:18-alpine
WORKDIR /app
RUN npm install -g {package}
CMD ["{package}"]
"""
        ),
        "pypi": LibraryRegistry(
            id="pypi",
            name="PyPI",
            type="pypi",
            search_cmd="pip index versions {query}",
            install_cmd="pip install {package}",
            run_cmd="python -m {package}",
            dockerfile_template="""FROM python:3.11-slim
WORKDIR /app
RUN pip install {package}
CMD ["python", "-m", "{package}"]
"""
        ),
        "docker": LibraryRegistry(
            id="docker",
            name="Docker Hub",
            type="docker",
            search_cmd="docker search {query} --format json",
            install_cmd="docker pull {package}",
            run_cmd="docker run -it {package}",
            dockerfile_template=""  # Already Docker image
        ),
        "cargo": LibraryRegistry(
            id="cargo",
            name="Crates.io",
            type="cargo",
            search_cmd="cargo search {query}",
            install_cmd="cargo install {package}",
            run_cmd="{package}",
            dockerfile_template="""FROM rust:latest
WORKDIR /app
RUN cargo install {package}
CMD ["{package}"]
"""
        ),
        "go": LibraryRegistry(
            id="go",
            name="Go Modules",
            type="go",
            search_cmd="go list -m {query}",
            install_cmd="go install {package}@latest",
            run_cmd="{package}",
            dockerfile_template="""FROM golang:latest
WORKDIR /app
RUN go install {package}@latest
CMD ["{package}"]
"""
        ),
    }
    
    # Makefile templates for different roles
    MAKEFILE_TEMPLATES = {
        "run": """# ============================================
# {app_name} - Makefile.run (System/Service)
# Auto-generated by Streamware
# ============================================

.PHONY: help start stop restart status health logs install clean

APP_NAME := {app_id}
APP_DIR := $(shell pwd)

help:
\t@echo "ðŸ”§ {app_name} - System Commands"
\t@echo "================================"
\t@echo "  start   - Start the service"
\t@echo "  stop    - Stop the service"
\t@echo "  status  - Check status"
\t@echo "  health  - Health check"
\t@echo "  logs    - Show logs"
\t@echo "  install - Install dependencies"

start:
\t@{start_cmd}
\t@echo '{{\"status\": \"started\", \"app\": \"$(APP_NAME)\"}}'

stop:
\t@{stop_cmd}
\t@echo '{{\"status\": \"stopped\", \"app\": \"$(APP_NAME)\"}}'

restart: stop start

status:
\t@echo '{{\"status\": \"running\", \"app\": \"$(APP_NAME)\"}}'

health:
\t@{health_cmd}

logs:
\t@tail -20 logs/app.log 2>/dev/null || echo "No logs"

install:
\t@{install_cmd}
\t@echo "âœ… Installed"

clean:
\t@rm -rf __pycache__ node_modules .cache
""",
        
        "user": """# ============================================
# {app_name} - Makefile.user (Daily Use)
# Auto-generated by Streamware
# ============================================

.PHONY: help {targets}

APP_NAME := {app_id}

# @text help: "Show available commands"
{target_annotations}

help:
\t@echo "ðŸ“¦ {app_name} - User Commands"
\t@echo "=============================="
{help_entries}

{target_rules}
""",
        
        "admin": """# ============================================
# {app_name} - Makefile.admin (Configuration)
# Auto-generated by Streamware
# ============================================

.PHONY: help config set enable disable backup restore

APP_NAME := {app_id}
ENV_FILE := $(shell pwd)/.env

# @text config: "Show configuration"
# @text enable: "Enable the app"
# @text disable: "Disable the app"
# @text backup: "Backup configuration"

help:
\t@echo "âš™ï¸ {app_name} - Admin Commands"
\t@echo "==============================="
\t@echo "  config  - Show configuration"
\t@echo "  enable  - Enable app"
\t@echo "  disable - Disable app"
\t@echo "  backup  - Backup config"

config:
\t@cat $(ENV_FILE) 2>/dev/null || echo "No config"

enable:
\t@sed -i 's/APP_ENABLED=.*/APP_ENABLED=true/' $(ENV_FILE)
\t@echo '{{\"enabled\": true}}'

disable:
\t@sed -i 's/APP_ENABLED=.*/APP_ENABLED=false/' $(ENV_FILE)
\t@echo '{{\"enabled\": false}}'

backup:
\t@mkdir -p backups
\t@cp $(ENV_FILE) backups/.env.$$(date +%Y%m%d)
\t@echo '{{\"backup\": \"created\"}}'
"""
    }
    
    def __init__(self, apps_dir: Path = None, llm_manager = None):
        self.apps_dir = apps_dir or Path(__file__).parent.parent / "apps"
        self.llm_manager = llm_manager
        logger.info("ðŸ­ AppGenerator initialized")
    
    async def search_registry(self, registry_id: str, query: str) -> List[Dict]:
        """Search library registry"""
        registry = self.LIBRARY_REGISTRIES.get(registry_id)
        if not registry:
            return []
        
        try:
            cmd = registry.search_cmd.format(query=query)
            result = subprocess.run(
                cmd, shell=True, capture_output=True, text=True, timeout=30
            )
            
            if result.returncode == 0:
                # Try to parse JSON output
                try:
                    return json.loads(result.stdout)
                except:
                    # Return raw lines as results
                    return [{"name": line.strip()} for line in result.stdout.split("\n") if line.strip()]
            return []
        except Exception as e:
            logger.error(f"Search failed: {e}")
            return []
    
    async def generate_app_from_package(
        self, 
        registry_id: str, 
        package_name: str,
        app_id: str = None,
        description: str = ""
    ) -> Dict[str, Any]:
        """Generate Streamware app from package"""
        
        registry = self.LIBRARY_REGISTRIES.get(registry_id)
        if not registry:
            return {"success": False, "error": f"Unknown registry: {registry_id}"}
        
        app_id = app_id or package_name.replace("/", "-").replace("@", "")
        app_path = self.apps_dir / app_id
        
        try:
            # Create app directory
            app_path.mkdir(parents=True, exist_ok=True)
            (app_path / "scripts").mkdir(exist_ok=True)
            (app_path / "logs").mkdir(exist_ok=True)
            
            # Generate manifest.toml
            manifest = self._generate_manifest(
                app_id=app_id,
                name=package_name,
                description=description or f"App from {registry.name}: {package_name}",
                registry_type=registry.type
            )
            (app_path / "manifest.toml").write_text(manifest)
            
            # Generate .env
            env_content = f"""# {package_name} Configuration
APP_ID={app_id}
APP_ENABLED=true
PACKAGE={package_name}
REGISTRY={registry_id}
"""
            (app_path / ".env").write_text(env_content)
            
            # Generate Makefiles
            makefiles = self._generate_makefiles(
                app_id=app_id,
                app_name=package_name,
                registry=registry,
                package_name=package_name
            )
            
            for filename, content in makefiles.items():
                (app_path / filename).write_text(content)
            
            # Generate Dockerfile if needed
            if registry.dockerfile_template:
                dockerfile = registry.dockerfile_template.format(package=package_name)
                (app_path / "Dockerfile").write_text(dockerfile)
            
            # Generate README
            readme = self._generate_readme(app_id, package_name, registry)
            (app_path / "README.md").write_text(readme)
            
            logger.info(f"âœ… App generated: {app_id} from {registry_id}/{package_name}")
            
            return {
                "success": True,
                "app_id": app_id,
                "path": str(app_path),
                "registry": registry_id,
                "package": package_name
            }
            
        except Exception as e:
            logger.error(f"Failed to generate app: {e}")
            return {"success": False, "error": str(e)}
    
    async def generate_app_from_api_docs(
        self,
        api_docs_url: str,
        app_id: str = None,
        app_name: str = None
    ) -> Dict[str, Any]:
        """Generate Streamware app from API documentation URL"""
        
        if not self.llm_manager:
            return {"success": False, "error": "LLM manager not available"}
        
        try:
            import httpx
            
            # Fetch API docs
            async with httpx.AsyncClient(timeout=30) as client:
                response = await client.get(api_docs_url)
                
                if response.status_code != 200:
                    return {"success": False, "error": f"Failed to fetch API docs: HTTP {response.status_code}"}
                
                api_docs_content = response.text[:10000]  # Limit size
            
            # Use LLM to generate app structure
            prompt = f"""Analyze this API documentation and generate a Streamware app.

API Documentation URL: {api_docs_url}
Content (first 10000 chars):
{api_docs_content}

Generate:
1. App ID (lowercase, no spaces)
2. App name
3. Description
4. List of main endpoints/commands (max 10)
5. For each command: name, description, example usage

Return as JSON:
{{
  "app_id": "...",
  "app_name": "...",
  "description": "...",
  "commands": [
    {{"name": "...", "description": "...", "endpoint": "...", "method": "GET/POST"}}
  ]
}}"""
            
            response = await self.llm_manager.chat(
                prompt,
                system_prompt="You are an API analyzer. Return only valid JSON."
            )
            
            if response.error:
                return {"success": False, "error": response.error}
            
            # Parse LLM response
            try:
                # Extract JSON from response
                json_match = re.search(r'\{[\s\S]*\}', response.content)
                if not json_match:
                    return {"success": False, "error": "Could not parse LLM response"}
                
                api_config = json.loads(json_match.group())
            except json.JSONDecodeError as e:
                return {"success": False, "error": f"Invalid JSON from LLM: {e}"}
            
            # Override with provided values
            app_id = app_id or api_config.get("app_id", "api-app")
            app_name = app_name or api_config.get("app_name", app_id)
            
            app_path = self.apps_dir / app_id
            
            # Create app directory
            app_path.mkdir(parents=True, exist_ok=True)
            (app_path / "scripts").mkdir(exist_ok=True)
            (app_path / "logs").mkdir(exist_ok=True)
            
            # Generate manifest
            manifest = self._generate_api_manifest(app_id, app_name, api_config, api_docs_url)
            (app_path / "manifest.toml").write_text(manifest)
            
            # Generate .env
            env_content = f"""# {app_name} Configuration
APP_ID={app_id}
APP_ENABLED=true
API_BASE_URL={api_docs_url.rsplit('/', 1)[0]}
API_TIMEOUT=30
"""
            (app_path / ".env").write_text(env_content)
            
            # Generate Makefiles with API commands
            makefiles = await self._generate_api_makefiles(app_id, app_name, api_config)
            for filename, content in makefiles.items():
                (app_path / filename).write_text(content)
            
            # Generate API client script
            api_script = self._generate_api_script(api_config)
            (app_path / "scripts" / "api_client.py").write_text(api_script)
            
            logger.info(f"âœ… API app generated: {app_id} from {api_docs_url}")
            
            return {
                "success": True,
                "app_id": app_id,
                "path": str(app_path),
                "api_url": api_docs_url,
                "commands": len(api_config.get("commands", []))
            }
            
        except Exception as e:
            logger.error(f"Failed to generate API app: {e}")
            return {"success": False, "error": str(e)}
    
    async def generate_makefiles_for_repo(
        self,
        repo_path: Path,
        app_id: str = None
    ) -> Dict[str, Any]:
        """Generate Makefiles for repository that doesn't have them"""
        
        if not self.llm_manager:
            return {"success": False, "error": "LLM manager not available"}
        
        app_id = app_id or repo_path.name
        
        # Analyze repo structure
        files = []
        for f in repo_path.rglob("*"):
            if f.is_file() and not any(p.startswith(".") for p in f.parts):
                files.append(str(f.relative_to(repo_path)))
        
        # Detect language/framework
        language = self._detect_language(files)
        
        # Read key files for context
        context_files = {}
        key_files = ["package.json", "requirements.txt", "Cargo.toml", "go.mod", "setup.py", "pyproject.toml"]
        for kf in key_files:
            kf_path = repo_path / kf
            if kf_path.exists():
                context_files[kf] = kf_path.read_text()[:2000]
        
        # Use LLM to generate Makefiles
        prompt = f"""Generate Makefiles for this repository.

Repository: {app_id}
Language: {language}
Files: {files[:50]}
Key files content:
{json.dumps(context_files, indent=2)}

Generate 3 Makefiles for Streamware:
1. Makefile.run - System commands (start, stop, health, install)
2. Makefile.user - User commands based on app functionality
3. Makefile.admin - Admin commands (config, enable, disable)

Each Makefile should have:
- @text annotations for text2makefile
- JSON output format where possible
- Proper .PHONY declarations

Return as JSON:
{{
  "Makefile.run": "...",
  "Makefile.user": "...",
  "Makefile.admin": "..."
}}"""
        
        response = await self.llm_manager.chat(
            prompt,
            system_prompt="You are a Makefile generator. Return valid JSON with Makefile contents."
        )
        
        if response.error:
            return {"success": False, "error": response.error}
        
        try:
            # Extract JSON
            json_match = re.search(r'\{[\s\S]*\}', response.content)
            if not json_match:
                # Fallback to template generation
                return self._generate_template_makefiles(repo_path, app_id, language)
            
            makefiles = json.loads(json_match.group())
            
            # Write Makefiles
            for filename, content in makefiles.items():
                if filename.startswith("Makefile"):
                    (repo_path / filename).write_text(content)
            
            # Also generate main Makefile
            main_makefile = self._generate_main_makefile(app_id)
            (repo_path / "Makefile").write_text(main_makefile)
            
            logger.info(f"âœ… Makefiles generated for: {app_id}")
            
            return {
                "success": True,
                "app_id": app_id,
                "path": str(repo_path),
                "makefiles": list(makefiles.keys()),
                "language": language
            }
            
        except Exception as e:
            logger.error(f"Failed to generate Makefiles: {e}")
            return self._generate_template_makefiles(repo_path, app_id, language)
    
    def _detect_language(self, files: List[str]) -> str:
        """Detect primary language from file list"""
        extensions = {}
        for f in files:
            ext = Path(f).suffix.lower()
            extensions[ext] = extensions.get(ext, 0) + 1
        
        lang_map = {
            ".py": "python",
            ".js": "javascript",
            ".ts": "typescript",
            ".go": "go",
            ".rs": "rust",
            ".rb": "ruby",
            ".java": "java",
            ".php": "php",
        }
        
        for ext, lang in lang_map.items():
            if ext in extensions:
                return lang
        
        return "unknown"
    
    def _generate_manifest(self, app_id: str, name: str, description: str, registry_type: str) -> str:
        """Generate manifest.toml"""
        return f'''# {name} Manifest
# Auto-generated by Streamware

[app]
id = "{app_id}"
name = "{name}"
version = "1.0.0"
description = "{description}"
language = "{registry_type}"
author = "Streamware"

[service]
type = "external"
registry = "{registry_type}"

[ui]
icon = "ðŸ“¦"
color = "#6366f1"
'''
    
    def _generate_api_manifest(self, app_id: str, name: str, api_config: Dict, api_url: str) -> str:
        """Generate manifest for API app"""
        commands = api_config.get("commands", [])
        commands_toml = "\n".join([
            f'"{cmd["name"]}" = ["api", "{cmd["name"]}"]'
            for cmd in commands
        ])
        
        return f'''# {name} Manifest
# Auto-generated from API: {api_url}

[app]
id = "{app_id}"
name = "{name}"
version = "1.0.0"
description = "{api_config.get('description', 'API integration')}"
language = "python"
author = "Streamware"

[service]
type = "api"
url = "{api_url}"

[commands]
{commands_toml}

[scripts]
api_client = "scripts/api_client.py"

[ui]
icon = "ðŸ”Œ"
color = "#3b82f6"
'''
    
    def _generate_makefiles(self, app_id: str, app_name: str, registry: LibraryRegistry, package_name: str) -> Dict[str, str]:
        """Generate all Makefiles for package"""
        
        makefiles = {}
        
        # Makefile.run
        makefiles["Makefile.run"] = self.MAKEFILE_TEMPLATES["run"].format(
            app_name=app_name,
            app_id=app_id,
            start_cmd=registry.run_cmd.format(package=package_name),
            stop_cmd="echo 'Stopping...'",
            health_cmd="echo '{\"status\": \"healthy\"}'",
            install_cmd=registry.install_cmd.format(package=package_name)
        )
        
        # Makefile.user
        makefiles["Makefile.user"] = f"""# {app_name} - User Commands
.PHONY: help run info

APP_NAME := {app_id}

# @text run: "Run the application"
# @text info: "Show app info"

help:
\t@echo "ðŸ“¦ {app_name} - User Commands"
\t@echo "  run  - Run the application"
\t@echo "  info - Show info"

run:
\t@{registry.run_cmd.format(package=package_name)}

info:
\t@echo '{{"app": "$(APP_NAME)", "package": "{package_name}"}}'
"""
        
        # Makefile.admin
        makefiles["Makefile.admin"] = self.MAKEFILE_TEMPLATES["admin"].format(
            app_name=app_name,
            app_id=app_id
        )
        
        # Main Makefile
        makefiles["Makefile"] = self._generate_main_makefile(app_id)
        
        return makefiles
    
    async def _generate_api_makefiles(self, app_id: str, app_name: str, api_config: Dict) -> Dict[str, str]:
        """Generate Makefiles for API app"""
        
        commands = api_config.get("commands", [])
        
        # Build user Makefile with API commands
        targets = " ".join([cmd["name"] for cmd in commands])
        annotations = "\n".join([
            f'# @text {cmd["name"]}: "{cmd["description"]}"'
            for cmd in commands
        ])
        help_entries = "\n".join([
            f'\t@echo "  {cmd["name"]} - {cmd["description"]}"'
            for cmd in commands
        ])
        target_rules = "\n".join([
            f'{cmd["name"]}:\n\t@python3 scripts/api_client.py {cmd["name"]}'
            for cmd in commands
        ])
        
        user_makefile = self.MAKEFILE_TEMPLATES["user"].format(
            app_name=app_name,
            app_id=app_id,
            targets=targets,
            target_annotations=annotations,
            help_entries=help_entries,
            target_rules=target_rules
        )
        
        return {
            "Makefile": self._generate_main_makefile(app_id),
            "Makefile.run": self.MAKEFILE_TEMPLATES["run"].format(
                app_name=app_name,
                app_id=app_id,
                start_cmd="echo 'API app started'",
                stop_cmd="echo 'Stopped'",
                health_cmd="python3 scripts/api_client.py health",
                install_cmd="pip install httpx"
            ),
            "Makefile.user": user_makefile,
            "Makefile.admin": self.MAKEFILE_TEMPLATES["admin"].format(
                app_name=app_name,
                app_id=app_id
            )
        }
    
    def _generate_api_script(self, api_config: Dict) -> str:
        """Generate API client script"""
        commands = api_config.get("commands", [])
        
        command_handlers = "\n".join([
            f'''    "{cmd["name"]}": {{
        "endpoint": "{cmd.get("endpoint", "/")}",
        "method": "{cmd.get("method", "GET")}",
        "description": "{cmd["description"]}"
    }},'''
            for cmd in commands
        ])
        
        return f'''#!/usr/bin/env python3
"""API Client for {api_config.get("app_name", "API")}"""

import sys
import os
import json
import httpx
from dotenv import load_dotenv

load_dotenv()

API_BASE_URL = os.getenv("API_BASE_URL", "")
API_TIMEOUT = int(os.getenv("API_TIMEOUT", "30"))

COMMANDS = {{
{command_handlers}
}}

def execute(command: str, *args):
    if command not in COMMANDS:
        print(json.dumps({{"error": f"Unknown command: {{command}}"}}))
        return
    
    cmd_config = COMMANDS[command]
    url = f"{{API_BASE_URL}}{{cmd_config['endpoint']}}"
    method = cmd_config["method"]
    
    try:
        with httpx.Client(timeout=API_TIMEOUT) as client:
            if method == "GET":
                response = client.get(url)
            else:
                response = client.post(url)
            
            print(response.text)
    except Exception as e:
        print(json.dumps({{"error": str(e)}}))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(json.dumps({{"commands": list(COMMANDS.keys())}}))
    else:
        execute(sys.argv[1], *sys.argv[2:])
'''
    
    def _generate_main_makefile(self, app_id: str) -> str:
        """Generate main Makefile entry point"""
        return f"""# {app_id} - Main Makefile
.PHONY: help run user admin

help:
\t@echo "ðŸ“¦ {app_id}"
\t@echo "  make run   - System commands"
\t@echo "  make user  - User commands"
\t@echo "  make admin - Admin commands"

run:
\t@make -f Makefile.run help

user:
\t@make -f Makefile.user help

admin:
\t@make -f Makefile.admin help

run-%:
\t@make -f Makefile.run $*

user-%:
\t@make -f Makefile.user $*

admin-%:
\t@make -f Makefile.admin $*
"""
    
    def _generate_template_makefiles(self, repo_path: Path, app_id: str, language: str) -> Dict[str, Any]:
        """Fallback: generate template Makefiles"""
        makefiles = {
            "Makefile": self._generate_main_makefile(app_id),
            "Makefile.run": self.MAKEFILE_TEMPLATES["run"].format(
                app_name=app_id,
                app_id=app_id,
                start_cmd="echo 'Starting...'",
                stop_cmd="echo 'Stopping...'",
                health_cmd="echo '{\"status\": \"healthy\"}'",
                install_cmd="echo 'Install manually'"
            ),
            "Makefile.admin": self.MAKEFILE_TEMPLATES["admin"].format(
                app_name=app_id,
                app_id=app_id
            )
        }
        
        for filename, content in makefiles.items():
            (repo_path / filename).write_text(content)
        
        return {
            "success": True,
            "app_id": app_id,
            "path": str(repo_path),
            "makefiles": list(makefiles.keys()),
            "language": language,
            "template": True
        }
    
    def _generate_readme(self, app_id: str, package_name: str, registry: LibraryRegistry) -> str:
        """Generate README.md"""
        return f"""# {package_name}

Generated by Streamware from {registry.name}.

## Installation

```bash
{registry.install_cmd.format(package=package_name)}
```

## Usage

```bash
make user-run
```

## Commands

- `make run` - System commands
- `make user` - User commands
- `make admin` - Admin commands

## Docker

```bash
docker build -t {app_id} .
docker run -it {app_id}
```
"""
    
    def get_available_registries(self) -> List[Dict]:
        """Get available library registries"""
        return [
            {
                "id": reg.id,
                "name": reg.name,
                "type": reg.type
            }
            for reg in self.LIBRARY_REGISTRIES.values()
        ]


# Global app generator instance (needs llm_manager injection)
app_generator = AppGenerator()
